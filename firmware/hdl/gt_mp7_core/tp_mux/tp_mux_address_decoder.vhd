--
-- Address decode logic for ipbus fabric.
-- Do NOT edit this file it will be AUTOGENERATED by gtu-ipbus-decoder.
--

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.math_pkg.all;

package ipbus_decode_tp_mux is

    -- Number of slaves defined in the address table.
    constant N_SLAVES: positive := 2;

    -- Define selection vector format.
    constant IPBUS_SEL_WIDTH: positive := log2c(N_SLAVES);
    subtype ipbus_sel_t is std_logic_vector(IPBUS_SEL_WIDTH - 1 downto 0);
    function ipbus_sel_tp_mux(addr : in std_logic_vector(31 downto 0)) return ipbus_sel_t;

    -- Item\'s unique identification index, used in slave implementation.
    constant C_IPB_TP_MUX0: integer := 0;
    constant C_IPB_TP_MUX1: integer := 1;

    -- Item\'s address width in bits, used in slave implementation.
    constant C_IPB_TP_MUX0_SIZE: integer := 5;

end ipbus_decode_tp_mux;

package body ipbus_decode_tp_mux is

    function ipbus_sel_tp_mux(addr : in std_logic_vector(31 downto 0)) return ipbus_sel_t is
        variable sel: ipbus_sel_t;

    begin
        if       std_match(addr, "101000000000000000000000000-----") then sel := ipbus_sel_t(to_unsigned(C_IPB_TP_MUX0, IPBUS_SEL_WIDTH)); -- 0xA0000000
        elsif    std_match(addr, "101000000000000000000000001-----") then sel := ipbus_sel_t(to_unsigned(C_IPB_TP_MUX1, IPBUS_SEL_WIDTH)); -- 0xA0000020
        else
            sel := ipbus_sel_t(to_unsigned(N_SLAVES, IPBUS_SEL_WIDTH));
        end if;

        return sel;

    end function ipbus_sel_tp_mux;

end ipbus_decode_tp_mux;
